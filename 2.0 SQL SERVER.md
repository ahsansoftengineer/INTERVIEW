SQL Server
## Indexes
1.	Cluster : 
Primary Key - Only One Clustered Index within a Table

2.	Non Cluster Index
-	Unique
-	Filtered
-	XML
-	Full Text
-	Spatial
-	Column Store
-	Index with Included Columns
-	Index on Computed Columns

3.	Composite Index - Multiple Column Index
Both Clustered Index & Non Clustered Index can have Composite Index

## SQL vs MySQL

## Unique Key VS Primary Key

## Constraint
1.	Not Null
2.	Unique
3.	Check
4.	Default
5.	Index Primary Key

## CHAR vs VARCHAR2 

## Joins
	Inner Join
	Full Join
	Left Join
	Right Join

## DBMS vs RDBMS
Hierarchical 
Network
Relational SQL
Object-Orient

## Subset of SQL
DDL -> Data Definition Language (Table Definitions etcâ€¦)
DML -> CRUD
DCL -> Rights and Permissions controls of the database system
TCL -> Transaction of Database

## Triggers
## Functions
## Stored Procedure

## KEY WORDS
-	Where and Having 
- 	Order By, Group By
-	Where
-	Aggregate (Count, Sum, Average, Min, Max, Rank, Dense_Rank, NTile, String_Agg, Group_Concat) etc..
-	
## Subqueries

## Query Execution Time

## Drop VS Truncate
	Truncate cannot be reverted
	Drop Command can be reverted



## NORMALIZATION
Certainly! Here's a brief explanation of the first three normal forms:
1. **First Normal Form (1NF):** In 1NF, data is organized so that each column contains atomic values, and there are no repeating groups within rows. It ensures that the data is structured into tables with unique rows and single, indivisible values in each cell.
2. **Second Normal Form (2NF):** To achieve 2NF, a table must already be in 1NF, and it must ensure that each non-key column is fully functionally dependent on the entire primary key. Partial dependencies are not allowed, and if they exist, the affected columns should be moved to a separate table with their own primary key.
3. **Third Normal Form (3NF):** In addition to the requirements of 1NF and 2NF, 3NF mandates that there should be no transitive dependencies. This means that non-key columns should not depend on other non-key columns. If such dependencies exist, the data should be further normalized to eliminate them.

Higher normal forms like BCNF and 4NF continue to refine database design by addressing more specific forms of redundancy and dependency. The goal of normalization is to reduce data anomalies, improve data integrity, and optimize database performance.

### BCNF 4NF
Certainly! Here's a brief explanation of BCNF (Boyce-Codd Normal Form) and 4NF (Fourth Normal Form):

**BCNF (Boyce-Codd Normal Form):** BCNF is a higher level of normalization that addresses certain anomalies in the data. To achieve BCNF, a table must meet the following criteria:
- It must be in 1NF (First Normal Form).
- It must be in 2NF (Second Normal Form).
- It must not have any non-prime attributes (non-key columns) that are functionally dependent on other non-prime attributes. In other words, all non-key attributes must be determined by the superkey (the set of attributes that uniquely identifies rows).

BCNF helps further eliminate redundancy and data anomalies by ensuring that non-key attributes depend only on the superkey.

**4NF (Fourth Normal Form):** 4NF is a level of normalization that addresses multi-valued dependencies. To achieve 4NF, a table must meet the following criteria:
- It must be in 1NF (First Normal Form).
- It must be in 2NF (Second Normal Form).
- It must be in 3NF (Third Normal Form).
- It must not have any non-key multi-valued dependencies. This means that a non-key attribute should not be functionally dependent on a subset of other non-key attributes.

4NF aims to eliminate redundancy and anomalies related to multi-valued data dependencies.

Both BCNF and 4NF are advanced stages of normalization that refine the database design by reducing potential anomalies and ensuring data integrity.

### ADVANTAGE OF NORMALIZATION
We normalize tables in a database for several important reasons:
1. **Minimize Data Redundancy:** Normalization reduces data redundancy by organizing data into separate tables and eliminating duplicate information. This not only saves storage space but also ensures data consistency by reducing the risk of inconsistencies and errors.
2. **Improve Data Integrity:** Normalization helps maintain data integrity by preventing anomalies such as insertion, update, or deletion anomalies. With properly structured tables, data is less likely to become inconsistent or incorrect.
3. **Optimize Database Performance:** Well-normalized databases typically perform better because they require fewer resources to manage data. Query execution becomes more efficient, leading to faster and more responsive database operations.
4. **Facilitate Scalability:** Normalization makes it easier to expand and modify the database schema without disrupting existing data. This flexibility is essential as requirements change over time.
5. **Enhance Data Maintainability:** A normalized database is easier to maintain and update. Changes to data structures can be made with minimal impact on the overall system, making maintenance tasks more straightforward.
6. **Support Data Consistency:** By reducing redundancy and enforcing data integrity, normalization helps maintain a consistent and accurate representation of the real-world entities and relationships within the database.
7. **Improve Data Quality:** Normalization encourages the use of a standardized structure for data, making it easier to validate and cleanse data for quality assurance.

In summary, normalization is a fundamental technique in database design that aims to eliminate redundancy, improve data integrity, enhance performance, and make databases more scalable and maintainable. It ensures that data is well-structured, consistent, and efficient, which is essential for effective and reliable database systems.