## C# Features
### C# CORE LEVEL
1. Assemblies, ILDasam, Jit Compiler, Aot Compiler

Dynamic C#
### Preprocessing
```c#
#define DEBUG
#if DEBUG Console.WriteLine("Debug mode is active."); 
#else Console.WriteLine("Debug mode is not active."); 
#endif
```

### Late Binding, Early Binding
1. We use Dynamic C# for Late Binding
2. Late binding, resolved at runtime based on the actual type of myObject 
### Async await, Task, Threading, Multithreading, Monitor & Lock, Deadlock

### Lock Example
```c#
lock (lockObject) 
{
  Thread.Sleep(100);
  Console.WriteLine($"Thread ID: {Thread.CurrentThread.ManagedThreadId}); 
}
``
### Reflection
```c#
Structs, Class, Interface
```
### Language Specific Topics
1. Garbage Collection 
2. Boxing Unboxing
3. Indexers, lightweight dynamic methods
4. Abstract, Static, Sealed, Partial, ref, out, Classes, Enums, Exceptions, Generics, Indexers
5. Multicast Delegate, Comparison Delegates
6. Hashset, Tupple,  Dictionary, List, IEnumerable, DSA 
7. Meta Packages

### GENERAL
1. Explicit Interface Implementation 
- (We Use Explicit Interface impl when we have two interface with same method in it)

Sync / Async API Gateway
Service Discovery
Load Balancing
Distributed Business Transaction
Metrics and Monitoring
Service Mesh
Dotnet Core Components
Middleware 
Dependency Injection
Authentication
Authorization


Design Patterns
Options
Singleton
Repository
Abstraction
Factory 
MediatorR CQS / CQRS
Circuit Breaker Pattern (Used in Middleware and Filters)
Decorator Pattern / Attributes / AOP (Aspect Oriented Programming) 


Best Practices
Centralized Logging
Centralized Error Handling
Generic Repository Pattern
CQS / CQRS

ACID Properties: Transactions adhere to the ACID properties, which stand for:
Atomicity: Ensures that all operations within a transaction are treated as a single unit. If any part of the transaction fails, the entire transaction is rolled back.
Consistency: Ensures that the data remains in a valid state before and after the transaction.
Isolation: Ensures that transactions are executed independently and do not interfere with each other.
Durability: Ensures that once a transaction is committed, its changes are permanent and will survive any system failures.

Cross Cutting Concern
This Components Required but its not really a part of the application
Loggin, Security, Profiling Transaction Management
Profiling  in a web application refers to the process of analyzing and measuring various aspects of the application's performance, resource usage, and behavior.

Library
Entity Framework with Stored Procedure & Functions
Linq, Linq to SQL, Linq to XML, Linq to In-memory Objects 
Filtering, Projection, Sorting, Set, Partitioning, Join, Aggregation
Pub Sub (RabbitMQ, HttpClient, TCP, gRPC, RPC, SignalR)
Software Policy and Regulatory Standard
Unit Testing, End to End Testing, XUnit, Fluent Assertions, FakeItEasy (Arrange, Act, Assert)
Reddish / Caching Data
Resiliency Patterns -> Polly Resilience 
Configuration
Clean Architecture Hierarchy  
```xml 
1. Presentation Layer
  <ItemGroup>
    <PackageReference Include="AspNetCoreRateLimit" Version="5.0.0" />
    <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" Version="12.0.1" />
    <PackageReference Include="Marvin.Cache.Headers" Version="6.1.0" />
    <PackageReference Include="Microsoft.AspNetCore.Mvc.Versioning" Version="5.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.StaticFiles" Version="2.2.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="7.0.5">
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="X.PagedList.Mvc.Core" Version="8.4.7" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\ProjectName.Domain\ProjectName.Domain.csproj" />
    <ProjectReference Include="..\ProjectName.Infra\ProjectName.Infra.csproj" />
  </ItemGroup>

2. Domain Layer
  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Mvc.NewtonsoftJson" Version="6.0.16" />
  </ItemGroup>


3. Data Access Layer

  <ItemGroup>
    <PackageReference Include="DynamicExpressions.NET" Version="1.1.0" />
    <PackageReference Include="LinqKit.Core" Version="1.2.4" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="7.0.5" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.OpenIdConnect" Version="7.0.5" />
    <PackageReference Include="Microsoft.AspNetCore.Identity.EntityFrameworkCore" Version="7.0.5" />
    <PackageReference Include="Microsoft.AspNetCore.Mvc.NewtonsoftJson" Version="7.0.5" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="7.0.5" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.DynamicLinq" Version="7.3.2" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="7.0.5" />
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="7.0.0" />
    <PackageReference Include="X.PagedList.Mvc.Core" Version="8.4.7" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\ProjectName.Domain\ProjectName.Domain.csproj" />
  </ItemGroup>
```









C# 

Dynamic C# Example 
string jsonData = "{\"name\":\"John\", \"age\":30, \"isEmployed\":true}"; 
dynamic person = Newtonsoft.Json.JsonConvert.DeserializeObject(jsonData);
Console.WriteLine($"Name: {person.name}");


As you can see, dynamic C# allows us to interact with dynamic data easily without creating a specific class to represent the JSON data. It also allows us to add new properties to the dynamic object at runtime, making it more flexible for working with data structures that may change or evolve during the application's execution.

Structs & Classes & Record & Interface
Structs: Structs are value types and are stored on the stack. When you create an instance of a struct, the entire struct's data is copied, and each instance is independent of others. Modifications to one instance do not affect other instances.
Classes: Classes are reference types and are stored on the heap. When you create an instance of a class, only a reference (memory address) is stored on the stack, pointing to the actual object's location on the heap. Multiple references can point to the same object in memory, so modifying one object through one reference will affect all references pointing to that object.
Struct VS Class
Inheritance and Polymorphism
Default Constructor
Performance Considerations
Value Type vs. Reference Type
Syntax of Writing Struct and Class is Identical
In C# 9, records were introduced as a new reference type designed primarily for immutable data structures. When you define a record, it generates a set of methods automatically, such as Equals(), GetHashCode(), ToString(), and Deconstruct(), 











































Task VS Thread
Its a good practice to only Thread is modify its property no other thread modify the property that is declare by other thread
That is how you can understand what to choose over async await & Thread
Async Await is Simpler but Thread is difficult to implement
Async/await is a feature in C# that allows you to write asynchronous code in a more readable and manageable way. It is built on top of the Task-based Asynchronous Pattern (TAP) and allows you to perform asynchronous operations without blocking the calling thread.
When you use async/await, the compiler generates code to handle asynchronous operations, allowing you to write code that looks synchronous but operates asynchronously, making it easier to manage asynchronous workflows.




























Middleware
Middleware Calls the next Middleware in the PipeLine
The Terminating Middle does not call the next middle it just return
To Continue Execution of the Code we to call the next() function for continue process
Channing PipeLine (Middleware Process)
Middleware A B C (A wrap around B and B Wrap around C and C is the Terminating Middleware)
App.Use(), app.Map() app.Run(), app.MapWhen(), app.UseWhen()
Creating Custom Middleware by IMiddleware has InvokeAsync Method
Then Register in DI Container
Then Add app.UseMiddleware<MiddlewareNameHere>();

Singleton Design Pattern
The singleton design pattern ensures that only one object of its kind exists, and provides global access to it for any other code. This design pattern can be implemented in a number of ways, using:
Thread-safety singleton
Thread-safety singleton using double-check locking
No thread-safe singleton
Thread-safe without a lock
.NET 4â€™s Lazy<T> type

Configurations
Settings files, such as appsettings.json
Environment variables
Azure Key Vault
Azure App Configuration
Command-line arguments
Custom providers, installed or created
Directory files
In-memory .NET objects


Linq Operators
Apologies for the confusion. I understand now that you are asking about the different categories of LINQ extension methods based on their operations. LINQ extension methods can be categorized into the following groups based on the type of operation they perform:

**Filtering Operators**:
`Where`: Filters elements from a sequence based on a specified condition.
`OfType`: Filters elements of a sequence based on their type.

**Projection Operators**:
`Select`: Projects each element of a sequence into a new form.
`SelectMany`: Projects each element of a sequence to a collection and flattens the resulting sequences into one sequence.

**Sorting Operators**:
`OrderBy`: Sorts elements of a sequence in ascending order based on a key.
`OrderByDescending`: Sorts elements of a sequence in descending order based on a key.
`ThenBy`: Performs a secondary sort on the elements of a sequence in ascending order based on a key.
`ThenByDescending`: Performs a secondary sort on the elements of a sequence in descending order based on a key.
`Reverse`: Reverses the order of elements in a sequence.

**Set Operators**:
`Distinct`: Returns distinct elements from a sequence.
`Union`: Produces the union of two sequences, removing duplicate elements.
`Intersect`: Produces the intersection of two sequences, returning elements that exist in both sequences.
`Except`: Produces the set difference of two sequences, returning elements that exist in the first sequence but not in the second sequence.

**Partitioning Operators**:
`Take`: Returns a specified number of elements from the start of a sequence.
`Skip`: Bypasses a specified number of elements from the start of a sequence.
`TakeWhile`: Returns elements from a sequence as long as a specified condition is true.
`SkipWhile`: Bypasses elements from a sequence as long as a specified condition is true.

**Join Operators**:
`Join`: Joins two sequences based on a common key.
`GroupJoin`: Performs a group join on two sequences based on a common key.

 **Aggregation Operators**:
`Count`: Returns the number of elements in a sequence.
`Sum`: Computes the sum of a sequence of numeric values.
`Average`: Computes the average of a sequence of numeric values.
`Min`: Returns the minimum value in a sequence.
`Max`: Returns the maximum value in a sequence.
`Aggregate`: Performs a custom aggregation operation on a sequence.

These are some of the major categories of LINQ extension methods based on the types of operations they perform. Each category contains multiple LINQ methods that provide various functionalities for querying and manipulating data in .NET applications.



Entity Framework with Stored Procedure Example 
CREATE PROCEDURE InsertEmployee
    @FirstName NVARCHAR(100),
    @LastName NVARCHAR(100),
    @Age INT
    @TotalEmployees INT OUTPUT
AS
BEGIN
    BEGIN TRANSACTION;

    INSERT INTO Employees (FirstName, LastName, Age)
    VALUES (@FirstName, @LastName, @Age);
    SELECT @TotalEmployees = COUNT(*) FROM Employees;

    COMMIT TRANSACTION;
END

public class Program
{
    public static void Main()
    {
        using (var dbContext = new EmployeeDbContext())
        {
            int targetEmployeeId = 1;
            var employeeIdParameter = new SqlParameter("@EmployeeId", targetEmployeeId);
            var totalEmployeesParameter = new SqlParameter
            {
                ParameterName = "@TotalEmployees",
                SqlDbType = SqlDbType.Int,
                Direction = ParameterDirection.Output
            };
            var employees = dbContext.Employees
                .FromSqlRaw("EXEC GetEmployeeByIdWithOutput 
@EmployeeId, @TotalEmployees OUTPUT", employeeIdParameter, totalEmployeesParameter).ToList();
            int totalEmployees = (int)totalEmployeesParameter.Value;
            Console.WriteLine($"Employee ID: {targetEmployeeId}, Total Employees: {totalEmployees}");
            foreach (var employee in employees)
            {
                Console.WriteLine($"Employee ID: { employee.EmployeeId }, Name: { employee.FirstName } { employee.LastName }, Age: {employee.Age}");
            }
        }
    }
}


Design Patterns

Design patterns are categorized into three main types based on their purpose and scope: creational patterns, structural patterns, and behavioral patterns. Each type of design pattern serves a specific purpose in software design.

1. **Creational Patterns**:
Creational patterns focus on object creation mechanisms, providing flexibility and control over object instantiation.

**Factory Method**: Creates objects without specifying the exact class of the object that will be created. Examples include LoggerFactory in .NET Core and LoggerFactory in Java.
**Abstract Factory**: Provides an interface for creating families of related or dependent objects without specifying their concrete classes. Examples include System.Data.Common.DbProviderFactory in .NET and javax.xml.parsers.DocumentBuilderFactory in Java.
**Singleton**: Ensures that a class has only one instance and provides a global point of access to that instance. Examples include Logger in many logging libraries and Runtime in Java.
**Builder**: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations. Examples include StringBuilder in .NET and StringBuilder in Java.
**Prototype**: Creates new objects by copying existing objects and modifying them if necessary. Examples include ICloneable interface in .NET and java.lang.Cloneable interface in Java.

2. **Structural Patterns**:
Structural patterns deal with the composition of classes and objects to form larger structures.

**Adapter**: Allows incompatible interfaces to work together by converting the interface of one class into another interface that clients expect. Examples include System.Data.Common.DbDataAdapter in .NET and java.util.Arrays.asList() in Java.
**Decorator**: Dynamically adds responsibilities to objects, providing a flexible alternative to subclassing for extending functionality. Examples include Stream classes in .NET and IO classes in Java.
**Facade**: Provides a simplified interface to a complex system, acting as a unified interface to a set of interfaces. Examples include high-level APIs in many libraries and Java Servlet API.
**Bridge**: Decouples an abstraction from its implementation, allowing both to vary independently. Examples include ADO.NET in .NET and JDBC in Java.
**Composite**: Composes objects into tree-like structures to represent part-whole hierarchies. Examples include System.Windows.Forms.Control in .NET and java.awt.Container in Java.

3. **Behavioral Patterns**:
Behavioral patterns focus on the interaction between objects and the delegation of responsibilities.

**Observer**: Defines a one-to-many dependency between objects, ensuring that when one object changes state, all its dependents are notified. Examples include INotifyPropertyChanged in .NET and java.util.Observer in Java.
**Strategy**: Encapsulates algorithms in separate classes and makes them interchangeable, allowing clients to choose the appropriate algorithm at runtime. Examples include Collections.sort() in Java and System.Text.StringBuilder in .NET.
**Command**: Encapsulates a request as an object, thereby allowing parameterization of clients with different requests and queuing of requests. Examples include ICommand interface in .NET and java.lang.Runnable interface in Java.
**Template Method**: Defines the skeleton of an algorithm in a method, deferring some steps to subclasses. Examples include System.Web.UI.Page in .NET and HttpServlet in Java.
**State**: Allows an object to alter its behavior when its internal state changes. Examples include System.Threading.Thread in .NET and javax.swing.ButtonModel in Java.

These are just a few examples of design patterns in each category. Design patterns help in solving common software design problems and promote flexibility, maintainability, and reusability in code. However, it's essential to choose the appropriate pattern based on the specific problem you are trying to solve and the characteristics of your software project.



Question / Answer
https://www.youtube.com/watch?v=FySr1tusL8c

Can we Store all types of data in an array
Yes If you create an array with object type  (b/c) all types derived from object base class
object[] objarr = new object[];

What is Jagged Arrays
Jagged Array is an Array of Arrays
String[][] jaggedArray = new string[3][];

What is the use case of abstract class
Abstract class is created when you want that class is only to be used as the base class
You cannot created instance directly of that class
Best Example Employee Class for PartTime Employee and FullTime Employee

What is the advantage of using Interface
Interfaces allow us to develop loosely coupled systems.
Interfaces are very useful for DI
Interfaces make Unit Testing and Mocking Easier
What is a recursive Function
A Recursive Function is a Function that calls itself
Mostly used with Hierarchy data that has Parent Child relationship with nth Level
Another Example Includes Factorial
Is it possible to store n number of lists of different data types in a List
Yes, by creating a List of List of Objects
List<List<object>> list = new List<List<object>>();
Type of Data Structures in C#
https://dev.to/adavidoaiei/fundamental-data-structures-and-algorithms-in-c-4ocf
Stack 
A stack is a linear data structure that follows the Last-In-First-Out (LIFO)
Stack<string> stack = new Stack<string>();
For topElement Use Peek, Pop, Push
Undo / Redo Browser back Buttons

Queue
Queue<string> numbers = new Queue<string>();
Contains, Clear, Count, Enque, Deque

Linked List
AddFirst, RemoveFirst, AddLast, RemoveLast, AddAfter, AddBefore, Find

Hashtable
Hashtable hashtable = new Hashtable();
Add, Remove, ContainsKey 
Use Dictionary If you are using (Version 2.0 or later),

Binary Search
Binary Search is an efficient searching algorithm used to find a specific element in a sorted collection (e.g., array) by repeatedly dividing the search range in half. It follows a divide-and-conquer approach,

Binary Search Tree (in a sorted order)
Use Binary Search Tree (BST) when you need to maintain a sorted collection of elements and perform various operations like searching, insertion, and deletion efficiently in a sorted order.

Graphs

Sorting Algorithms



Dictionary<key, value> Pairs



